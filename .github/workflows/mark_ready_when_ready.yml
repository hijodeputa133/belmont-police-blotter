name: Mark PR Ready When Ready

on:
  pull_request:
    types:
      - opened
      - labeled
      - unlabeled
      - synchronize

permissions:
  actions: read
  checks: read
  contents: write
  pull-requests: write
  statuses: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  wait_for_workflows:
    name: Mark as ready after successful workflow suite
    runs-on: ubuntu-latest
    if: |
      contains(github.event.pull_request.labels.*.name, 'Mark Ready When Ready') &&
      github.event.pull_request.draft == true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Wait for workflows
        uses: actions/github-script@e69ef5462fd455e02edcaf4dd7708eda96b9eda0 # v7.0.0
        id: wait
        env:
          MAX_TIMEOUT: "1800"
          POLLING_INTERVAL: "30"
          EXCLUDE_WORKFLOW_NAMES: ""
          EXCLUDE_WORKFLOW_IDS: ""
          WORKFLOW_RUN_ID: ${{ github.run_id }}
          DEBUG: "true"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            async function checkWorkflows(
              github,
              context,
              EXCLUDE_WORKFLOW_NAMES,
              EXCLUDE_WORKFLOW_IDS,
              EXCLUDE_WORKFLOW_RUN_IDS,
            ) {
              const { DEBUG, GITHUB_SHA } = process.env;

              const WORKFLOW_RUNS_FOR_REPO_RESPONSE =
                await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.payload.repository.owner.login,
                  repo: context.payload.repository.name,
                  head_sha: context.payload.after || GITHUB_SHA,
                });

              if (DEBUG) {
                console.log(
                  "workflow_runs length:",
                  WORKFLOW_RUNS_FOR_REPO_RESPONSE.data.workflow_runs.length,
                );
                const workflows = WORKFLOW_RUNS_FOR_REPO_RESPONSE.data.workflow_runs.reduce(
                  (acc, val) =>
                    acc.concat([
                      {
                        run_id: val.id,
                        name: val.name,
                        workflow_id: val.workflow_id,
                        run_attempt: val.run_attempt,
                      },
                    ]),
                  [],
                );
                console.log("workflow_runs:", workflows);
              }

              const FAILED_WORKFLOWS =
                WORKFLOW_RUNS_FOR_REPO_RESPONSE.data.workflow_runs.filter(
                  (run) =>
                    !EXCLUDE_WORKFLOW_RUN_IDS.includes(run.id) &&
                    !EXCLUDE_WORKFLOW_NAMES.includes(run.name) &&
                    !EXCLUDE_WORKFLOW_IDS.includes(run.workflow_id) &&
                    (run.status == "failure" || run.conclusion == "failure"),
                );

              const PENDING_WORKFLOWS =
                WORKFLOW_RUNS_FOR_REPO_RESPONSE.data.workflow_runs.filter(
                  (run) =>
                    !EXCLUDE_WORKFLOW_RUN_IDS.includes(run.id) &&
                    !EXCLUDE_WORKFLOW_NAMES.includes(run.name) &&
                    !EXCLUDE_WORKFLOW_IDS.includes(run.workflow_id) &&
                    (run.status == "queued" || run.status == "in_progress"),
                );

              if (FAILED_WORKFLOWS.length > 0) {
                console.log(
                  `${FAILED_WORKFLOWS.length} failing workflows. Canceling the rest of workflow.`,
                );
                FAILED_WORKFLOWS.forEach((workflow) => {
                  console.log(
                    `Workflow: name=${workflow.name} id=${workflow.id} status=${workflow.status} conclusion=${workflow.conclusion}`,
                  );
                });

                process.exit(1);
              }

              if (PENDING_WORKFLOWS.length > 0) {
                console.log(`Waiting for ${PENDING_WORKFLOWS.length} workflows to finish:`);
                PENDING_WORKFLOWS.forEach((workflow) => {
                  console.log(
                    `Workflow: name=${workflow.name} id=${workflow.id} status=${workflow.status}`,
                  );
                });

                return true;
              }
              return false;
            }

            async function sleep(seconds) {
              return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
            }

            const { DEBUG } = process.env;

            if (DEBUG) {
              console.log(`process.env.MAX_TIMEOUT: ${process.env.MAX_TIMEOUT}`);
              console.log(`process.env.POLLING_INTERVAL: ${process.env.POLLING_INTERVAL}`);
              console.log(
                `process.env.EXCLUDE_WORKFLOW_NAMES: ${process.env.EXCLUDE_WORKFLOW_NAMES}`,
              );
              console.log(
                `process.env.EXCLUDE_WORKFLOW_IDS: ${process.env.EXCLUDE_WORKFLOW_IDS}`,
              );
              console.log("context:", context);
            }

            const MAX_TIMEOUT = Number(process.env.MAX_TIMEOUT);
            const POLLING_INTERVAL = Number(process.env.POLLING_INTERVAL);
            const EXCLUDE_WORKFLOW_NAMES =
              process.env.EXCLUDE_WORKFLOW_NAMES == ""
                ? []
                : process.env.EXCLUDE_WORKFLOW_NAMES.split(",");
            const EXCLUDE_WORKFLOW_IDS =
              process.env.EXCLUDE_WORKFLOW_IDS == ""
                ? []
                : process.env.EXCLUDE_WORKFLOW_IDS.split(",");
            const EXCLUDE_WORKFLOW_RUN_IDS = [Number(process.env.WORKFLOW_RUN_ID)];

            if (DEBUG) {
              console.log(`MAX_TIMEOUT: ${MAX_TIMEOUT}`);
              console.log(`POLLING_INTERVAL: ${POLLING_INTERVAL}`);
              console.log(`EXCLUDE_WORKFLOW_NAMES: ${EXCLUDE_WORKFLOW_NAMES}`);
              console.log(`EXCLUDE_WORKFLOW_IDS: ${EXCLUDE_WORKFLOW_IDS}`);
              console.log(`EXCLUDE_WORKFLOW_RUN_IDS: ${EXCLUDE_WORKFLOW_RUN_IDS}`);
            }

            let timer = 0;

            await sleep(5);

            console.log(
              `Waiting time ${timer}s out of ${MAX_TIMEOUT}s with polling interval ${POLLING_INTERVAL}s`,
            );
            while (
              timer < MAX_TIMEOUT &&
              (await checkWorkflows(
                github,
                context,
                EXCLUDE_WORKFLOW_NAMES,
                EXCLUDE_WORKFLOW_IDS,
                EXCLUDE_WORKFLOW_RUN_IDS,
              ))
            ) {
              await sleep(POLLING_INTERVAL);
              timer += POLLING_INTERVAL;
              console.log(
                `Waiting time ${timer}s out of ${MAX_TIMEOUT}s with polling interval ${POLLING_INTERVAL}s`,
              );
            }

            if (timer >= MAX_TIMEOUT) {
              console.error(`Wait for workflows is over MAX_TIMEOUT of ${MAX_TIMEOUT}s`);
              process.exit(1);
            }

      - name: Mark as ready
        env:
          GH_TOKEN: ${{ github.token }}
        if: |
          contains(github.event.pull_request.labels.*.name, 'Mark Ready When Ready') &&
          github.event.pull_request.draft == true &&
          steps.wait.outcome == 'success'
        run: gh pr ready ${{ github.event.pull_request.number }}
